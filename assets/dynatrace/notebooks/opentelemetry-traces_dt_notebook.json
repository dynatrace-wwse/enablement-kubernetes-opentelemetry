{
    "version": "7",
    "defaultTimeframe": {
        "from": "now()-30m",
        "to": "now()"
    },
    "defaultSegments": [],
    "sections": [
        {
            "id": "1ea70792-e9c3-4ed4-99c1-2e069ce65026",
            "type": "markdown",
            "markdown": "#### OpenTelemetry Collector for Traces\n\nDistributed traces and their spans, generated by OpenTelemetry agents and SDKs, are exported from their origin to an otlp receiver. These traces/spans can be sent directly to Dynatrace, using the OTLP ingest API. However, it is highly recommended to use the OpenTelemetry Collector to process, filter, and manipulate the data first."
        },
        {
            "id": "17ed96f7-6a92-49b3-88d2-c6e545dda210",
            "type": "markdown",
            "markdown": "`otlp` Receiver\n```\nconfig:\n    receivers:\n      otlp:\n        protocols:\n          grpc:\n            endpoint: 0.0.0.0:4317\n          http:\n            endpoint: 0.0.0.0:4318\n    service:\n      pipelines:\n        traces:\n          receivers: [otlp]\n          processors: [batch]\n          exporters: [otlphttp/dynatrace]\n```"
        },
        {
            "id": "28495e75-2d00-43e7-9220-a7ea20256dde",
            "type": "dql",
            "filterSegments": [],
            "drilldownPath": [],
            "previousFilterSegments": [],
            "state": {
                "input": {
                    "timeframe": {
                        "from": "now()-30m",
                        "to": "now()"
                    },
                    "value": "fetch spans\n| filter isNotNull(service.name) and isNotNull(service.namespace) and isNotNull(otel.scope.name)\n| sort start_time desc\n| limit 100\n| fields start_time, end_time, service.name, service.namespace, trace.id, span.id, duration"
                },
                "visualizationSettings": {
                    "chartSettings": {}
                },
                "querySettings": {
                    "maxResultRecords": 1000,
                    "defaultScanLimitGbytes": 500,
                    "maxResultMegaBytes": 1,
                    "defaultSamplingRatio": 10,
                    "enableSampling": false
                },
                "davis": {
                    "includeLogs": true,
                    "davisVisualization": {
                        "isAvailable": true
                    }
                }
            }
        },
        {
            "id": "671eedc0-e637-4977-82af-7f374726c191",
            "type": "markdown",
            "markdown": "#### PaymentService Spans\n\nNow that you've confirmed OpenTelemetry spans are successfully ingested into Dynatrace, it's time to narrow your focus to a specific business-critical function: payment processing. In this next step, you'll refine your DQL query to isolate traces and spans related to the `paymentservice` workload and the `charge` operation. This targeted analysis allows you to observe how Dynatrace captures and contextualizes telemetry data for a key service, helping you validate instrumentation, understand service behavior, and identify potential performance bottlenecks in the payment flow."
        },
        {
            "id": "c57bbdd9-ef07-4810-8929-b9775b506e1e",
            "type": "dql",
            "filterSegments": [],
            "drilldownPath": [],
            "previousFilterSegments": [],
            "state": {
                "input": {
                    "timeframe": {
                        "from": "now()-30m",
                        "to": "now()"
                    },
                    "value": "fetch spans\n| filter isNotNull(service.name) and isNotNull(service.namespace) and isNotNull(otel.scope.name)\n| filter matchesValue(service.name,\"paymentservice\") and matchesValue(endpoint.name,\"oteldemo.PaymentService.Charge\")\n| sort start_time desc\n| limit 10\n| fields start_time, end_time, service.name, service.namespace, trace.id, span.id, duration, app.payment.amount"
                },
                "visualizationSettings": {
                    "chartSettings": {}
                },
                "querySettings": {
                    "maxResultRecords": 1000,
                    "defaultScanLimitGbytes": 500,
                    "maxResultMegaBytes": 1,
                    "defaultSamplingRatio": 10,
                    "enableSampling": false
                },
                "davis": {
                    "includeLogs": true,
                    "davisVisualization": {
                        "isAvailable": true
                    }
                }
            }
        },
        {
            "id": "5cadaa5a-acf9-4eb3-a000-9bf520183eab",
            "type": "markdown",
            "markdown": "#### k8sattributes Processor\nAdd Kubernetes Attributes with the `k8sattributes` Processor\n\nThe Kubernetes Attributes Processor automatically discovers Kubernetes pods, extracts their metadata, and adds the extracted metadata to spans, metrics, and logs as resource attributes.\n\nThe Kubernetes Attributes Processor is one of the most important components for a collector running in Kubernetes. Any collector receiving application data should use it. Because it adds Kubernetes context to your telemetry, the Kubernetes Attributes Processor lets you correlate your applicationâ€™s traces, metrics, and logs signals with your Kubernetes telemetry, such as pod metrics and traces."
        },
        {
            "id": "6f754b6c-80f3-446e-9c3d-dfd6e353334f",
            "type": "markdown",
            "markdown": "`k8sattributes` Processor\n```\nk8sattributes:\n    auth_type: \"serviceAccount\"\n    passthrough: false\n        filter:\n        node_from_env_var: KUBE_NODE_NAME\n    extract:\n        metadata:\n            - k8s.namespace.name\n            - k8s.deployment.name\n            - k8s.daemonset.name\n            - k8s.job.name\n            - k8s.cronjob.name\n            - k8s.replicaset.name\n            - k8s.statefulset.name\n            - k8s.pod.name\n            - k8s.pod.uid\n            - k8s.node.name\n            - k8s.container.name\n            - container.id\n            - container.image.name\n            - container.image.tag\n        labels:\n        - tag_name: app.label.component\n            key: app.kubernetes.io/component\n            from: pod\n    pod_association:\n        - sources:\n            - from: resource_attribute\n              name: k8s.pod.uid\n        - sources:\n            - from: resource_attribute\n              name: k8s.pod.name\n        - sources:\n            - from: resource_attribute\n              name: k8s.pod.ip\n        - sources:\n            - from: connection\n```"
        },
        {
            "id": "02011c33-b69d-480a-942f-c7d2e1c9b8e9",
            "type": "dql",
            "filterSegments": [],
            "drilldownPath": [],
            "previousFilterSegments": [],
            "state": {
                "input": {
                    "timeframe": {
                        "from": "now()-30m",
                        "to": "now()"
                    },
                    "value": "fetch spans\n| filter isNotNull(service.name) and isNotNull(service.namespace) and isNotNull(otel.scope.name)\n| filter matchesValue(service.name,\"paymentservice\") and matchesValue(endpoint.name,\"oteldemo.PaymentService.Charge\")\n| filter isNotNull(app.label.component)\n| sort start_time desc\n| limit 10\n| fields start_time, end_time, service.name, service.namespace, trace.id, span.id, duration, app.payment.amount, app.label.component"
                },
                "visualizationSettings": {
                    "chartSettings": {}
                },
                "querySettings": {
                    "maxResultRecords": 1000,
                    "defaultScanLimitGbytes": 500,
                    "maxResultMegaBytes": 1,
                    "defaultSamplingRatio": 10,
                    "enableSampling": false
                },
                "davis": {
                    "includeLogs": true,
                    "davisVisualization": {
                        "isAvailable": true
                    }
                }
            }
        },
        {
            "id": "d4b66b86-58f5-4b59-8f83-8487f5fdf11e",
            "type": "markdown",
            "markdown": "#### resourcedetection Processor\nAdd `resourcedetection` Processor\n\nThe resource detection processor can be used to detect resource information from the host, in a format that conforms to the OpenTelemetry resource semantic conventions, and append or override the resource value in telemetry data with this information. Detectors are available for AWS, Azure, GCP, and several other platforms; see the documentation for more details."
        },
        {
            "id": "928fba78-41c0-4c35-ad6f-a29b09b05dbf",
            "type": "markdown",
            "markdown": "`resourcedetection` Processor\n```\nprocessors:\n  resourcedetection/gcp:\n    detectors: [env, gcp]\n    timeout: 2s\n    override: false\n```"
        },
        {
            "id": "4bc5730a-7608-442a-a0fb-3d817d13dc52",
            "type": "dql",
            "filterSegments": [],
            "drilldownPath": [],
            "previousFilterSegments": [],
            "state": {
                "input": {
                    "timeframe": {
                        "from": "now()-30m",
                        "to": "now()"
                    },
                    "value": "fetch spans\n| filter isNotNull(service.name) and isNotNull(service.namespace) and isNotNull(otel.scope.name)\n| filter matchesValue(service.name,\"paymentservice\") and matchesValue(endpoint.name,\"oteldemo.PaymentService.Charge\")\n| filter isNotNull(app.label.component) and isNotNull(cloud.account.id)\n| sort start_time desc\n| limit 10\n| fields start_time, end_time, service.name, service.namespace, trace.id, span.id, duration, app.payment.amount, app.label.component, cloud.account.id, k8s.cluster.name"
                },
                "visualizationSettings": {
                    "chartSettings": {}
                },
                "querySettings": {
                    "maxResultRecords": 1000,
                    "defaultScanLimitGbytes": 500,
                    "maxResultMegaBytes": 1,
                    "defaultSamplingRatio": 10,
                    "enableSampling": false
                },
                "davis": {
                    "includeLogs": true,
                    "davisVisualization": {
                        "isAvailable": true
                    }
                }
            }
        },
        {
            "id": "17062c69-b67b-41b5-a36f-8ef76f10434c",
            "type": "markdown",
            "markdown": "#### resource Processor\nAdd `resource` Processor\n\nThe resource processor allows us to directly add, remove, or change resource attributes on the telemetry. View the documentation for more details.\n\nWe will use this processor to make the follow changes to our telemetry: \n\n* `k8s.pod.ip` values in our data are either the same or invalid; delete the useless attribute \n* `telemetry.sdk.name` set to opentelemetry will allow us to easily identify data captured through OpenTelemetry \n* `dynatrace.otel.collector` is a non-standardized attribute that we made up to help us identify which Collector captured this data \n* `dt.security_context` is a Dynatrace specific attribute that we use to manage user permissions to the telemetry \n  * This could also be set using OpenPipeline, but this puts control of this attribute's value at the app/infra layer (optionally)"
        },
        {
            "id": "cefb109d-5728-4423-a87a-720ac462e1cd",
            "type": "markdown",
            "markdown": "`resource` Processor\n```\nprocessors:\n    resource:\n        attributes:\n        - key: k8s.pod.ip\n          action: delete\n        - key: telemetry.sdk.name\n          value: opentelemetry\n          action: insert\n        - key: dynatrace.otel.collector\n          value: dynatrace-traces\n          action: insert\n        - key: dt.security_context\n          from_attribute: k8s.cluster.name\n          action: insert\n```"
        },
        {
            "id": "de3d5936-f733-48fe-b4cd-23f990651987",
            "type": "dql",
            "filterSegments": [],
            "drilldownPath": [],
            "previousFilterSegments": [],
            "state": {
                "input": {
                    "timeframe": {
                        "from": "now()-30m",
                        "to": "now()"
                    },
                    "value": "fetch spans\n| filter isNotNull(service.name) and isNotNull(service.namespace) and isNotNull(otel.scope.name)\n| filter matchesValue(service.name,\"paymentservice\") and matchesValue(endpoint.name,\"oteldemo.PaymentService.Charge\")\n| filter isNotNull(app.label.component) and isNotNull(cloud.account.id) and isNotNull(dynatrace.otel.collector)\n| sort start_time desc\n| limit 10\n| fields start_time, end_time, service.name, service.namespace, trace.id, span.id, duration, app.payment.amount, app.label.component, cloud.account.id, k8s.cluster.name, dynatrace.otel.collector"
                },
                "visualizationSettings": {
                    "chartSettings": {}
                },
                "querySettings": {
                    "maxResultRecords": 1000,
                    "defaultScanLimitGbytes": 500,
                    "maxResultMegaBytes": 1,
                    "defaultSamplingRatio": 10,
                    "enableSampling": false
                },
                "davis": {
                    "includeLogs": true,
                    "davisVisualization": {
                        "isAvailable": true
                    }
                }
            }
        }
    ]
}